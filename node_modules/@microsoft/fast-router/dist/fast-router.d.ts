import { ComposableStyles } from '@microsoft/fast-element';
import { Constructable } from '@microsoft/fast-element';
import { ExecutionContext } from '@microsoft/fast-element';
import { FASTElement } from '@microsoft/fast-element';
import { HTMLDirective } from '@microsoft/fast-element';
import { ViewTemplate } from '@microsoft/fast-element';

/**
 * @internal
 */
export declare const childRouteParameter = "fast-child-route";

/**
 * @alpha
 */
export declare type CommandFallbackRouteDefinition<TSettings = any> = HasCommand & SupportsSettings<TSettings> & HasTitle;

/**
 * @alpha
 */
export declare type CommandRouteDefinition<TSettings = any> = PathedRouteDefinition<TSettings> & HasCommand & HasTitle;

/**
 * @alpha
 */
export declare class ConfigurableRoute implements Route {
    readonly path: string;
    readonly name: string;
    readonly caseSensitive: boolean;
    constructor(path: string, name: string, caseSensitive: boolean);
}

/**
 * @alpha
 */
export declare type ContributorOptions = {
    lifecycle?: boolean;
    parameters?: boolean;
};

/**
 * @alpha
 */
export declare type ConverterObject = {
    convert: RouteParameterConverter;
};

/**
 * @alpha
 */
export declare class DefaultLinkHandler implements LinkHandler {
    private handler;
    connect(): void;
    disconnect(): void;
    private getEventInfo;
    private findClosestAnchor;
    private targetIsThisWindow;
}

/**
 * @alpha
 */
export declare class DefaultNavigationProcess<TSettings> {
    private phases;
    run(router: Router, message: NavigationMessage): Promise<void>;
    commit(phase: NavigationPhaseImpl): void;
}

/**
 * @alpha
 */
export declare class DefaultNavigationQueue implements NavigationQueue, NavigationHandler {
    private queue;
    private promise;
    private resolve;
    connect(): void;
    disconnect(): void;
    receive(): Promise<NavigationMessage>;
    enqueue(msg: NavigationMessage): void;
    private tryDequeue;
    handleEvent(event: PopStateEvent): void;
}

/**
 * @alpha
 */
export declare class DefaultRouter implements Router {
    readonly host: HTMLElement;
    private parentRouter;
    private contributors;
    private navigationQueue;
    private linkHandler;
    private newView;
    private newRoute;
    private childCommandContributor;
    private childRoute;
    private isConnected;
    private routerConfig;
    private view;
    route: RecognizedRoute | null;
    constructor(host: HTMLElement);
    get config(): RouterConfiguration | null;
    set config(value: RouterConfiguration | null);
    get parent(): Router<any> | null;
    get level(): number;
    shouldRender(route: RecognizedRoute): boolean;
    beginRender(route: RecognizedRoute, command: RenderCommand): Promise<{
        commit: any;
        rollback: any;
    }>;
    connect(): void;
    disconnect(): void;
    addContributor(contributor: NavigationContributor): void;
    removeContributor(contributor: NavigationContributor): void;
    private tryConnect;
    private onNavigationMessage;
    private renderOperationCommit;
    private renderOperationRollback;
    private navigate;
    private leave;
    private construct;
    private enter;
    private commit;
    private tunnel;
}

/**
 * @alpha
 */
export declare class DefaultRouteRecognizer<TSettings> implements RouteRecognizer<TSettings> {
    private names;
    private paths;
    private readonly rootState;
    add(routeOrRoutes: Route | readonly Route[], settings?: TSettings): void;
    private $add;
    recognize(path: string, converters?: Readonly<Record<string, RouteParameterConverter>>): Promise<RecognizedRoute<TSettings> | null>;
    /**
     * Generate a path and query string from a route name and params object.
     *
     * @param name - The name of the route to generate from.
     * @param params - The route params to use when populating the pattern.
     * Properties not required by the pattern will be appended to the query string.
     * @returns The generated absolute path and query string.
     */
    generateFromName(name: string, params: object): string | null;
    /**
     * Generate a path and query string from a route path and params object.
     *
     * @param path - The path of the route to generate from.
     * @param params - The route params to use when populating the pattern.
     * Properties not required by the pattern will be appended to the query string.
     * @returns The generated absolute path and query string.
     */
    generateFromPath(path: string, params: object): string | null;
    private generate;
}

/**
 * @alpha
 */
export declare type DefinitionCallback = () => Promise<FallbackRouteDefinition> | FallbackRouteDefinition;

/**
 * @alpha
 */
export declare type ElementFallbackRouteDefinition<TSettings = any> = LayoutAndTransitionRouteDefinition & HasElement & SupportsSettings<TSettings> & HasTitle;

/**
 * @alpha
 */
export declare type ElementRouteDefinition<TSettings = any> = NavigableRouteDefinition<TSettings> & HasElement;

/**
 * @alpha
 */
export declare class Endpoint<TSettings = any> {
    readonly route: ConfigurableRoute;
    readonly paramNames: readonly string[];
    readonly paramTypes: readonly string[];
    readonly settings: TSettings | null;
    constructor(route: ConfigurableRoute, paramNames: readonly string[], paramTypes: readonly string[], settings: TSettings | null);
    get path(): string;
}

/**
 * @alpha
 */
export declare type FallbackRouteDefinition<TSettings = any> = ElementFallbackRouteDefinition<TSettings> | TemplateFallbackRouteDefinition<TSettings> | Pick<RedirectRouteDefinition<TSettings>, "redirect"> | CommandFallbackRouteDefinition<TSettings>;

/**
 * @alpha
 */
export declare type FASTElementConstructor = new () => FASTElement;

/**
 * @alpha
 */
export declare class FASTElementLayout implements Layout {
    private readonly template;
    private runBeforeCommit;
    private styles;
    constructor(template?: ViewTemplate | null, styles?: ComposableStyles | ComposableStyles[] | null, runBeforeCommit?: boolean);
    beforeCommit(routerElement: HTMLElement): Promise<void>;
    afterCommit(routerElement: HTMLElement): Promise<void>;
    private apply;
}

/**
 * @alpha
 */
export declare class FASTRouter extends FASTRouter_base {
}

declare const FASTRouter_base: new () => FASTElement & RouterElement;

/**
 * @alpha
 */
export declare type HasCommand = {
    command: NavigationCommand;
};

/**
 * @alpha
 */
export declare type HasElement = {
    element: string | FASTElementConstructor | HTMLElement | (() => Promise<string | FASTElementConstructor | HTMLElement>);
};

/**
 * @alpha
 */
export declare type HasTemplate = {
    template: ViewTemplate | (() => Promise<ViewTemplate>);
};

/**
 * @alpha
 */
export declare type HasTitle = {
    title?: string;
};

/**
 * @alpha
 */
export declare type IgnorableRouteDefinition<TSettings = any> = PathedRouteDefinition<TSettings>;

/**
 * @alpha
 */
export declare class Ignore implements NavigationCommand {
    createContributor(): Promise<{
        navigate(phase: NavigationPhase): Promise<void>;
    }>;
}

/**
 * @alpha
 */
export declare function isFASTElementHost(host: HTMLElement): host is HTMLElement & FASTElement;

/**
 * @alpha
 */
export declare function isNavigationPhaseContributor<T extends NavigationPhaseName>(object: any, phase: T): object is Record<T, NavigationPhaseHook>;

/**
 * @alpha
 */
export declare interface Layout {
    beforeCommit(routerElement: HTMLElement): Promise<void>;
    afterCommit(routerElement: HTMLElement): Promise<void>;
}

/**
 * @alpha
 */
export declare const Layout: Readonly<{
    default: Readonly<Layout>;
}>;

/**
 * @alpha
 */
export declare type LayoutAndTransitionRouteDefinition = {
    layout?: Layout | ViewTemplate;
    transition?: Transition;
};

/**
 * @alpha
 */
export declare interface LinkHandler {
    connect(): void;
    disconnect(): void;
}

/**
 * @alpha
 */
export declare type MappableRouteDefinition<TSettings = any> = RenderableRouteDefinition<TSettings> | RedirectRouteDefinition<TSettings> | CommandRouteDefinition<TSettings> | ParentRouteDefinition<TSettings>;

/**
 * @alpha
 */
export declare type NavigableRouteDefinition<TSettings = any> = PathedRouteDefinition<TSettings> & LayoutAndTransitionRouteDefinition & HasTitle & {
    childRouters?: boolean;
};

/**
 * @alpha
 */
export declare interface NavigationCommand {
    createContributor(router: Router, route: RecognizedRoute): Promise<NavigationContributor>;
}

/**
 * @alpha
 */
export declare interface NavigationCommitPhase<TSettings = any> extends Omit<NavigationPhase<TSettings>, "cancel" | "canceled" | "onCancel"> {
    setTitle(title: string): any;
}

/**
 * @alpha
 */
export declare type NavigationCommitPhaseHook<TSettings = any> = (phase: NavigationCommitPhase<TSettings>) => Promise<any> | any;

/**
 * @alpha
 */
export declare type NavigationContributor<TSettings = any> = Partial<Record<Exclude<NavigationPhaseName, "commit">, NavigationPhaseHook<TSettings>>> & {
    commit?: NavigationCommitPhaseHook<TSettings>;
};

/**
 * @alpha
 */
export declare function navigationContributor(options?: ContributorOptions): HTMLDirective;

/**
 * @alpha
 */
export declare interface NavigationHandler {
    enqueue(msg: NavigationMessage): void;
}

/**
 * @alpha
 */
export declare const NavigationHandler: Readonly<{
    register(handler: NavigationHandler): void;
    unregister(handler: NavigationHandler): void;
}>;

/**
 * @alpha
 */
export declare class NavigationMessage {
    path: string;
    constructor(path: string);
}

/**
 * @alpha
 */
export declare interface NavigationPhase<TSettings = any> {
    readonly name: NavigationPhaseName;
    readonly route: RecognizedRoute<TSettings>;
    readonly router: Router<TSettings>;
    readonly canceled: boolean;
    cancel(callback?: NavigationPhaseFollowupAction): void;
    onCancel(callback: NavigationPhaseFollowupAction): void;
    onCommit(callback: NavigationPhaseFollowupAction): void;
    evaluateContributor(contributor: any, route?: RecognizedRoute<TSettings>, router?: Router<TSettings>): Promise<void>;
}

/**
 * @alpha
 */
export declare type NavigationPhaseFollowupAction = () => Promise<any> | any;

/**
 * @alpha
 */
export declare type NavigationPhaseHook<TSettings = any> = (phase: NavigationPhase<TSettings>) => Promise<any> | any;

declare class NavigationPhaseImpl<TSettings = any> implements NavigationCommitPhase<TSettings> {
    readonly name: NavigationPhaseName;
    private readonly commitActions;
    private readonly cancelActions;
    private routes;
    private routers;
    canceled: boolean;
    titles: Array<Array<string>>;
    get route(): RecognizedRoute<TSettings>;
    get router(): Router;
    constructor(name: NavigationPhaseName, route: RecognizedRoute<TSettings>, router: Router<TSettings>, commitActions: NavigationPhaseFollowupAction[], cancelActions: NavigationPhaseFollowupAction[]);
    cancel(callback?: NavigationPhaseFollowupAction): void;
    onCommit(callback: NavigationPhaseFollowupAction): void;
    onCancel(callback: NavigationPhaseFollowupAction): void;
    setTitle(title: string): void;
    evaluateContributor(contributor: any, route?: RecognizedRoute<TSettings>, router?: Router): Promise<void>;
}

/**
 * @alpha
 */
export declare type NavigationPhaseName = "navigate" | "leave" | "construct" | "enter" | "commit";

/**
 * @alpha
 */
export declare interface NavigationProcess {
    run(router: Router, message: NavigationMessage): Promise<void>;
}

/**
 * @alpha
 */
export declare interface NavigationQueue {
    connect(): void;
    disconnect(): void;
    receive(): Promise<NavigationMessage>;
}

/**
 * @alpha
 */
export declare type ParameterConverter = RouteParameterConverter | ConverterObject | Constructable<ConverterObject>;

/**
 * @alpha
 */
export declare type ParentRouteDefinition<TSettings = any> = PathedRouteDefinition<TSettings> & LayoutAndTransitionRouteDefinition & {
    children: MappableRouteDefinition<TSettings>[];
};

/**
 * @alpha
 */
export declare type PathedRouteDefinition<TSettings = any> = SupportsSettings<TSettings> & Route;

/**
 * @alpha
 */
export declare const QueryString: Readonly<{
    readonly current: string;
    /**
     * Generate a query string from an object.
     *
     * @param params - Object containing the keys and values to be used.
     * @param traditional - Boolean Use the old URI template standard (RFC6570)
     * @returns The generated query string, excluding leading '?'.
     */
    build(params: Object, traditional?: boolean | undefined): string;
    /**
     * Separate the query string from the path and returns the two parts.
     * @param path - The path to separate.
     */
    separate(path: string): Readonly<{
        path: string;
        queryString: string;
    }>;
    /**
     * Parse a query string.
     *
     * @param queryString - The query string to parse.
     * @returns Object with keys and values mapped from the query string.
     */
    parse(queryString: string): Readonly<Record<string, string>>;
}>;

/**
 * @alpha
 */
export declare class RecognizedRoute<TSettings = any> {
    readonly endpoint: Endpoint<TSettings>;
    readonly params: Readonly<Record<string, string | undefined>>;
    readonly typedParams: Readonly<Record<string, any>>;
    readonly queryParams: Readonly<Record<string, string>>;
    readonly allParams: Readonly<Record<string, string | undefined>>;
    readonly allTypedParams: Readonly<Record<string, any>>;
    constructor(endpoint: Endpoint<TSettings>, params: Readonly<Record<string, string | undefined>>, typedParams: Readonly<Record<string, any>>, queryParams: Readonly<Record<string, string>>);
    get settings(): TSettings | null;
}

/**
 * @alpha
 */
export declare class Redirect implements NavigationCommand {
    private redirect;
    constructor(redirect: string);
    createContributor(): Promise<{
        navigate(phase: NavigationPhase): Promise<void>;
    }>;
}

/**
 * @alpha
 */
export declare type RedirectRouteDefinition<TSettings = any> = PathedRouteDefinition<TSettings> & {
    redirect: string;
};

/**
 * @alpha
 */
export declare class Render implements RenderCommand {
    private owner;
    createView: () => Promise<RouteView>;
    private _layout;
    private _transition;
    title: string;
    constructor(owner: RouterConfiguration, createView: () => Promise<RouteView>);
    get transition(): Transition;
    set transition(value: Transition);
    get layout(): Layout;
    set layout(value: Layout);
    createContributor(router: Router, route: RecognizedRoute): Promise<RenderContributor>;
    static fromDefinition(owner: RouterConfiguration, definition: ElementRouteDefinition | TemplateRouteDefinition | ElementFallbackRouteDefinition | TemplateFallbackRouteDefinition): Render;
}

/**
 * @alpha
 */
export declare type RenderableRouteDefinition<TSettings = any> = ElementRouteDefinition<TSettings> | TemplateRouteDefinition<TSettings>;

/**
 * @alpha
 */
export declare interface RenderCommand extends NavigationCommand {
    layout: Layout;
    transition: Transition;
    createView(): Promise<RouteView>;
}

declare class RenderContributor {
    private router;
    private route;
    private command;
    private operation;
    constructor(router: Router, route: RecognizedRoute, command: Render);
    construct(phase: NavigationPhase): Promise<void>;
    commit(phase: NavigationCommitPhase): Promise<void>;
}

/**
 * @alpha
 */
export declare interface RenderOperation {
    commit(): Promise<void>;
    rollback(): Promise<void>;
}

/**
 * @alpha
 */
export declare interface Route {
    readonly path: string;
    readonly name?: string;
    readonly caseSensitive?: boolean;
}

/**
 * @alpha
 */
export declare const Route: Readonly<{
    path: Readonly<{
        readonly current: string;
        generateRoute(relativeTo: HTMLElement | Router, path: string, params?: Object): Promise<string | null>;
        push(path: string, trigger?: boolean): void;
        replace(path: string, trigger?: boolean): void;
        trigger(path: string): void;
    }>;
    name: Readonly<{
        generateRoute(relativeTo: HTMLElement | Router, name: string, params?: Object): Promise<string | null>;
        push(relativeTo: HTMLElement | Router, name: string, params?: Object, trigger?: boolean): Promise<void>;
        replace(relativeTo: HTMLElement | Router, name: string, params?: Object, trigger?: boolean): Promise<void>;
        trigger(relativeTo: HTMLElement | Router, name: string, params?: Object): Promise<void>;
    }>;
}>;

/**
 * @alpha
 */
export declare class RouteCollection<TSettings = any> {
    private owner;
    private _recognizer;
    private pathToCommand;
    private fallbackCommand;
    private fallbackSettings;
    private converters;
    constructor(owner: RouterConfiguration);
    private get recognizer();
    ignore(definitionOrString: IgnorableRouteDefinition<TSettings> | string): void;
    map(...routes: MappableRouteDefinition<TSettings>[]): void;
    fallback(definitionOrCallback: FallbackRouteDefinition<TSettings> | DefinitionCallback): void;
    converter(name: string, converter: ParameterConverter): void;
    recognize(path: string): Promise<RouteMatch<TSettings> | null>;
    /**
     * Generate a path and query string from a route name and params object.
     *
     * @param name - The name of the route to generate from.
     * @param params - The route params to use when populating the pattern.
     * Properties not required by the pattern will be appended to the query string.
     * @returns The generated absolute path and query string.
     */
    generateFromName(name: string, params: object): string | null;
    /**
     * Generate a path and query string from a route path and params object.
     *
     * @param path - The path of the route to generate from.
     * @param params - The route params to use when populating the pattern.
     * Properties not required by the pattern will be appended to the query string.
     * @returns The generated absolute path and query string.
     */
    generateFromPath(path: string, params: object): string | null;
    private aggregateConverters;
}

/**
 * @alpha
 */
export declare type RouteMatch<TSettings = any> = {
    route: RecognizedRoute<TSettings>;
    command: NavigationCommand;
};

/**
 * @alpha
 */
export declare type RouteParameterConverter = (value: string | undefined) => any | Promise<any>;

/**
 * @alpha
 */
export declare interface Router<TSettings = any> {
    readonly level: number;
    readonly parent: Router | null;
    readonly route: RecognizedRoute | null;
    config: RouterConfiguration | null;
    connect(): void;
    disconnect(): void;
    shouldRender(route: RecognizedRoute<TSettings>): boolean;
    beginRender(route: RecognizedRoute<TSettings>, command: RenderCommand): Promise<RenderOperation>;
    addContributor(contributor: NavigationContributor): void;
    removeContributor(contributor: NavigationContributor): void;
}

/**
 * @alpha
 */
export declare const Router: Readonly<{
    getOrCreateFor(element: HTMLElement): Router<any> | DefaultRouter;
    find(element: HTMLElement): Router | null;
    from<TBase extends {
        new (): HTMLElement;
        prototype: HTMLElement;
    }>(BaseType: TBase): new () => InstanceType<TBase> & RouterElement;
}>;

/**
 * @alpha
 */
export declare abstract class RouterConfiguration<TSettings = any> {
    private isConfigured;
    readonly routes: RouteCollection<TSettings>;
    readonly contributors: NavigationContributor<TSettings>[];
    defaultLayout: Layout;
    defaultTransition: Readonly<Transition>;
    title: string;
    parent: RouterConfiguration<TSettings> | null;
    createNavigationQueue(): NavigationQueue;
    createLinkHandler(): LinkHandler;
    createNavigationProcess(): NavigationProcess;
    createEventSink(): RoutingEventSink;
    createTitleBuilder(): TitleBuilder;
    createRouteRecognizer(): RouteRecognizer<TSettings>;
    construct<T>(Type: Constructable<T>): T;
    recognizeRoute(path: string): Promise<RouteMatch<TSettings> | null>;
    /**
     * Generate a path and query string from a route name and params object.
     *
     * @param name - The name of the route to generate from.
     * @param params - The route params to use when populating the pattern.
     * Properties not required by the pattern will be appended to the query string.
     * @returns The generated absolute path and query string.
     */
    generateRouteFromName(name: string, params: object): Promise<string | null>;
    /**
     * Generate a path and query string from a route path and params object.
     *
     * @param path - The path of the route to generate from.
     * @param params - The route params to use when populating the pattern.
     * Properties not required by the pattern will be appended to the query string.
     * @returns The generated absolute path and query string.
     */
    generateRouteFromPath(path: string, params: object): Promise<string | null>;
    findContributors<T extends NavigationPhaseName>(phase: T): Record<T, NavigationPhaseHook<TSettings>>[];
    protected abstract configure(): Promise<void> | void;
    protected cached(ElementType: new () => HTMLElement): () => Promise<HTMLElement>;
    private ensureConfigured;
}

/**
 * @alpha
 */
export declare interface RouteRecognizer<TSettings> {
    add(routeOrRoutes: Route | readonly Route[], settings?: TSettings): void;
    recognize(path: string, converters?: Readonly<Record<string, RouteParameterConverter>>): Promise<RecognizedRoute<TSettings> | null>;
    generateFromName(name: string, params: object): string | null;
    generateFromPath(path: string, params: object): string | null;
}

/**
 * @alpha
 */
export declare interface RouterElement extends HTMLElement {
    readonly [routerProperty]: Router;
    config: RouterConfiguration | null;
    connectedCallback(): any;
    disconnectedCallback(): any;
}

/**
 * @alpha
 */
export declare type RouterExecutionContext = ExecutionContext & {
    router: Router;
};

/**
 * @alpha
 */
export declare const RouterExecutionContext: Readonly<{
    create(router: Router): any;
}>;

declare const routerProperty = "$router";

/**
 * @alpha
 */
export declare interface RouteView {
    bind(allTypedParams: Readonly<Record<string, any>>, context: RouterExecutionContext): void;
    appendTo(host: HTMLElement): void;
    dispose(): void;
}

/**
 * @alpha
 */
declare interface RoutingEventSink {
    onUnhandledNavigationMessage(router: Router, message: NavigationMessage): void;
    onNavigationBegin(router: Router, route: RecognizedRoute, command: NavigationCommand): void;
    onPhaseBegin(phase: NavigationPhase): void;
    onPhaseEnd(phase: NavigationPhase): void;
    onNavigationEnd(router: Router, route: RecognizedRoute, command: NavigationCommand): void;
}

/**
 * @alpha
 */
export declare type SupportsSettings<TSettings = any> = {
    settings?: TSettings;
};

/**
 * @alpha
 */
export declare type TemplateFallbackRouteDefinition<TSettings = any> = LayoutAndTransitionRouteDefinition & HasTemplate & SupportsSettings<TSettings> & HasTitle;

/**
 * @alpha
 */
export declare type TemplateRouteDefinition<TSettings = any> = NavigableRouteDefinition<TSettings> & HasTemplate;

/**
 * @alpha
 */
declare interface TitleBuilder {
    joinTitles(parentTitle: string, childTitle: string): string;
    buildTitle(rootTitle: string, routeTitles: string[][]): string;
}

/**
 * @alpha
 */
export declare interface Transition {
    begin(host: HTMLElement, prev: RouteView | null, next: RouteView): Promise<void>;
    rollback(host: HTMLElement, prev: RouteView | null, next: RouteView): Promise<void>;
    commit(host: HTMLElement, prev: RouteView | null, next: RouteView): Promise<void>;
}

/**
 * @alpha
 */
export declare const Transition: Readonly<{
    default: Readonly<Transition>;
}>;

export { }
